each line must begin with a time marker

no free text editing. editing is line by line.
can add headings or lyrics
[chorus]
<0:00> olisa doo olisa doo
<0:13>* Nna dubem oo nye m ude gi oh
<0:15> Aga m agbachazi nbo gbara aka laa
<>Imana mu na Chi m so

line {
  pendingRevisions: [],
  mediaID:
  startTime:
  endTime:
  deleted: false,
  text:
  heading: null || "string",
  lastEdit: {dateTime}
  //lastEditBy: null || "userID" //null, if never revised by another,
	version: {integer++}
}

//id can change until annotated or edited
revision: {
  forID: {ObjectID},
  state: {"pending" || "applied" || "done"},
  newValues : <update doc>,
  original: {line}
  user: {ObjectID}
  target: {"media" || "lines"}
  date: {dateTime}
  mediaID: {ObjectID}, //for easy querying
  changeset: 
}

changeset {
	type: "new" || null,
	mediaID: "string" || null,
	user: {ObjectID}
}


media: {
	pendingRevisions: [],
	status: "draft"||"published"||"deleted",
  creator: {ObjectID},
	version: {integer++},
	title: "string",
	slug: Slugify(this.title),
	artist: "string", /* for now */
	img: "string",
	totalViews: {integer},
	history: [/*viewing history*/]
	type: 0 || 1, /* audio= 0, video=1 */
	/*for audio type */
	src: "string", /*formally 'url' */

}


1***Editing lyric:
-r=Revisions.insert(({state: "pending", targe: "lines"}))
==>can optimisticly be displayed at this point
-Songs.find({id: revisions.songID}, (song)=>{
	song.update({
		$set: {"lyric.$": r.new},
		$push: {pendingRevisions: r.id}
		});

})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "applied"
})
-Songs.find({id: revisions.songID}, (song)=>{
	song.pendingRevisions.pull(r.id),
})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "done"
})

/*
handle: what if two ppl are adding lyrics at the same time?
*/
2***Adding lyric:
-r=Revisions.insert(({state: "pending", action: "add_lyric"}))
==>could optimisticly be displayed at this point
-Songs.find({_id: revisions.songID}, (song)=>{
	song.update({
		$push: {
			pendingRevisions: r.id,
			lyrics: r.new
			}
		});
})
=>better to wait till this point, so at least concurrent editing will display
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "applied"
})
-Songs.find({id: revisions.songID}, (song)=>{
	song.pendingRevisions.pull(r.id),
})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "done"
})


3***Adding Song:
-s=Songs.insert(new Song());
=>send form to client
===>on cancel, delete
===>on save, next
-r=Revisions.insert(({state: "pending", action: "insert_song", new: <update doc>}))
-Songs.find({id: revisions.songID}, (song)=>{
	song.update({
		$set: r.new,
		$push: {pendingRevisions: r.id}
		});
})
==>can optimisticly be displayed at this point
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "applied"
})
-Songs.find({id: revisions.songID}, (song)=>{
	song.pendingRevisions.pull(r.id),
})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "done"
})



Editing Song Info:
-r=Revisions.insert(({state: "pending", action: "edit_song", <update doc>}))
==>can optimisticly be displayed at this point
-Songs.find({id: revisions.songID}, (song)=>{
	song.update({
		$set: r.new,
		$push: {pendingRevisions: r.id}
		});
})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "applied"
})
-Songs.find({id: revisions.songID}, (song)=>{
	song.pendingRevisions.pull(r.id),
})
-Revisions.find({_id: r.id}, (revision)=>{
	revision.state = "done"
})


Editing Control
- User turns on edit mode (15-minute timer starts, and restarts with each edit)
- Requests changeset from server
- all edits are tagged with changset id
- each line "add" will be committed
- but line "edits" are staged until:
-- user gets server version number line
-- if version number matches uesr version, then it goes through
-- if not, revision is canceled, and goes to trash, but user, should have views refreshed
---user version not matching, will typically happen, if 
    someone else (user2) has started editing since user1 retrieved server version 
    so user2's edit will go over user1's, since user2 was editing the latest version
    there is no "locking". whoever edits first, wins.

    version 7
    --> 9:01 AM user1 editing version 8 --> user 1 sees version==9
    --------> 9:04 AM user2 editing version 8--->user2 saves version 8

to avoid clashes, in the future, the more popular a song is,
 the fewer people will have the privilege of editing it